priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/} (${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}${0}
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r")) {
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vec "std::vector (v)" w
vector<${2:int}> $1
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cla "An entire .h generator" b
#ifndef ${2:`!v substitute(vim_snippets#Filename('$1_H','ClassName'),'.*','\U&\E','')`}
#define $2

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
	${3}

public:
	$1();
	virtual ~$1();
};

#endif /* $2 */
endsnippet
# vim:ft=snippets:



#***********************************************************************************
#for algorithm contest
#***********************************************************************************


#misc

snippet rep "for 0 n - 1" w
for (int ${1:i} = 0; $1 < $2; $1++) $3
endsnippet
    
snippet repp "for a b" w
for (${5:int} ${1:i} = $2; $1 <= $3; $1++) $4
endsnippet

snippet red "for n - 1 0 --" w
for (int ${2:i} = $1 - 1; $2 >= 0; $2--) $3
endsnippet

snippet redd "for a b --" w
for (${5:int} ${1:i} = $2; $1 >= $3; $1--) $4
endsnippet

snippet mpy "memcpy array" w
memcpy($1, $2, sizeof($1));$3
endsnippet

snippet mst "memset array" w
memset($1, ${2:0}, sizeof($1));$3
endsnippet

snippet pii "pair int int" w 
pair<int, int>$1
endsnippet

snippet pq "priority queue" w 
priority_queue<${2:int}> $1;
endsnippet

snippet pqp "priority queue of pair" w 
priority_queue<$1, vector<$1>, greater<$1>> $2;
endsnippet

snippet all "begin(), end()" w
$1.begin(), $1.end()${2}
endsnippet

snippet sort "sort(begin, end)" w
sort(${1:numbers}.begin(), $1.end());

endsnippet

snippet uniq "unique and resize" w
${1:numbers}.resize(unique($1.begin(), $1.end()) - $1.begin());

endsnippet

snippet pcnt "pop_bount" w
__builtin_popcount($1)$2
endsnippet

snippet lb "lower_bound" w 
lower_bound($1.begin(), $1.end(), $2)
endsnippet

snippet ub "upper_bound" w 
upper_bound($1.begin(), $1.end(), $2)
endsnippet

#code template

snippet cf "codeforces header file" b
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main() {
  ios::sync_with_stdio(0);
  $1


  return 0;
}
endsnippet

snippet gcj "google code jam header file" b
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main() {
  ios::sync_with_stdio(0);
  int t, ca = 1;
  $1


  return 0;
}
endsnippet

snippet nb "without bits header" b
#include <vector>
#include <cstdio>
#include <bitset>
#include <utility>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <set>
#include <map>
#include <deque>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <string>
#include <iostream>
#include <algorithm>
#include <functional>

typedef long long LL;
using namespace std;

int main() {
  ios::sync_with_stdio(0);
  $1


  return 0;
}
endsnippet

snippet seg "segment define" b
#define L (x << 1)
#define R (x << 1 | 1)
#define MID ((l + r) >> 1)
#define LC L, l, MID 
#define RC R, MID + 1, r

endsnippet

snippet mat "matrix define" b
typedef int Matrix[N][N];
Matrix ret, tmp, base;

void Mul(Matrix &a, Matrix &b) {
  for(int i = 0; i < N; i++) for (int j = 0; j < N; j++) tmp[i][j] = $1;
  for(int i = 0; i < N; i++) for (int j = 0; j < N; j++) {
    for (int k = 0; k < N; k++) tmp[i][j] = $2;
  }
  memcpy(a, tmp, sizeof(a));
}

void Powd(${3:int} b) {
  for(int i = 0; i < N; i++) for (int j = 0; j < N; j++) ret[i][j] = $1;
  for(; b; b >>= 1) {
    if (b & 1) Mul(ret, base);
    Mul(base, base);
  }
}

endsnippet

snippet ac "automation" b 
struct Automation{
  int tr[N][Z], fail[N], val[N], node;

  int Node() {
    memset(tr[node], 0, sizeof(tr[node]));
    fail[node] = 0;
    return node++;
  }

  void Init() {
    node = 0;
    Node();
  }

  void Insert(char *s, int y) {
    int pos = 0, x, now = 0;
    while (s[pos]) {
      x = s[pos++] - 'a';
      if (!tr[now][x]) {
        tr[now][x] = Node();
      }
      now = tr[now][x];
    }
    val[now] = y;
  }

  void Build() {
    int x, y;
    queue<int> q;
    REP(i, Z) {
      x = tr[0][i];
      if (x) {
        fail[x] = 0;
        q.push(x);
      }
    }

    while (!q.empty()) {
      x = q.front(); q.pop();
      REP(i, Z) {
        if (!tr[x][i]) {
          tr[x][i] = tr[fail[x]][i];
          continue;
        }
        y = tr[x][i];
        q.push(y);
        fail[y] = tr[fail[x]][i];
        val[y] += val[fail[y]];
      }
    }
  }
}AC;

$1
endsnippet

snippet add "add module" w
void Add(int &x, int y) {
  x += y;
  if (x >= MO) x -= MO;
}

endsnippet

snippet prime "get prime" w 
int visited[N], p[N], tot;

void Prime() {
  for (int i = 2; i < N; i++) {
    if (!visited[i]) p[tot++] = i;
    for (int j = 0; j < tot && i * p[j] < N; j++) {
      visited[i * p[j]] = p[j];
      if (i % p[j] == 0) break;
    }
  }
}

endsnippet

snippet gauss "gauss elimination" w 
int Gauss(int n) {
  int rank = 0;
  for (int i = 0; i < K; i++) {
    bool find = 0;
    for (int j = rank; j < n; j++) {
      if (${1:a}[j] & (1LL << i)) {
        find = 1;
        swap($1[rank], $1[j]);
        break;
      }
    }
    if (find) {
      for (int j = 0; j < n; j++) if (j != rank) {
        if ($1[j] & (1LL << i)) {
          $1[j] ^= $1[rank];
        }
      }
      rank++
    }
  }
  return rank;
}

endsnippet


snippet powd "power module" w
${1:int} Powd(${1:int} x, ${1:int} y) {
  ${1:int} ans = 1;
  for (; y; y >>= 1) {
    if (y & 1) ans = 1LL * ans * x % MO;
    x = 1LL * x * x % MO;
  }
  return ans;
}
endsnippet

snippet time "cerr time" w 
cerr << "---------------------------" << endl;
cerr << "Time used: " << setprecision(6) << 1.0 * clock() / CLOCKS_PER_SEC << " sec." << endl;
$1
endsnippet

snippet dinic "max flow" b 
template<int NODE, int EDGE, typename Type>
struct MaxFlow{
  int edge, source, sink;
  int level[NODE], current[NODE];
  int first[NODE], next[EDGE << 1], to[EDGE << 1];
  Type cap[EDGE << 1];
  const Type INF = ${2:1e9};

  void Init(int S, int T) {
    source = S, sink = T;
    edge = 1, memset(first, 0, sizeof(first));
  }

  void add(int x, int y, Type z) {
    next[++edge] = first[x]; first[x] = edge; to[edge] = y; cap[edge] = z;
  }

  void Add(int x, int y, Type z) {
    add(x, y, z);
    add(y, x, 0);
  }

  bool Bfs() {
    queue<int> q;
    memset(level, 0, sizeof(level));
    q.push(source), level[source] = 1;
    while(q.size()) {
      int x = q.front(); q.pop();
      for (int go = first[x]; go; go = next[go]) if (cap[go] > 0 && !level[to[go]]) {
        int y = to[go];
        level[y] = level[x] + 1;
        q.push(y);
      }
    }
    return level[sink];
  }

  Type Dfs(int x, Type flow) {
    if (x == sink || flow == 0) {
      return flow;
    }
    Type ans = 0, tmp = 0;
    for (int &go = current[x]; go; go = next[go]) if (cap[go] > 0) {
      int y = to[go];
      if (level[y] == level[x] + 1 && (tmp = Dfs(y, min(flow, cap[go]))) > 0) {
        ans += tmp, flow -= tmp;
        cap[go] -= tmp, cap[go ^ 1] += tmp;
        if (flow == 0) {
          return ans;
        }
      }
    }
    return ans;
  }

  Type Dinic() {
    Type ans = 0;
    while (Bfs()) {
      memcpy(current, first, sizeof(first));
      ans += Dfs(source, INF);
    }	
    return ans;
  }
};
MaxFlow<${3:100000}, ${4:100000}, ${1:int}> flow;

endsnippet

snippet pt "palindrome tree" b 
struct PT{
  struct Node{
    Node *ch[C], *suffix;
    int len;
  }bar[N], *foo, *last, *odd, *even;
  char s[N];
  int n, cnt;//cnt = foo - bar = count of palindromes, n the number of char added

  void init() {
    odd = bar, even = last = odd + 1, foo = even + 1;
    MST(odd->ch, 0), MST(even->ch, 0);
    odd->suffix = even->suffix = odd;
    odd->len = -1, even->len = 0;
    n = 0, cnt = 2;//root
  }

  Node* New_Node(int x) {
    MST(foo->ch, 0), foo->len = x;
    return foo++;
  }

  int index(char c) {
    return c - 'a';
  }

  Node* get(Node *p) {
    while (n - p->len - 2 < 0 || s[n - p->len - 2] != s[n - 1]) p = p->suffix;
    return p;
  }

  bool add(char c) {
    int x = index(c); s[n++] = c;
    Node *p = get(last);
    if (!p->ch[x]) {
      last = New_Node(p->len + 2);
      if (last->len == 1) {
        last->suffix = even;
      }
      else last->suffix = get(p->suffix)->ch[x];//guarantee proper suffix
      p->ch[x] = last;
      cnt++;
      return 1;
    }
    else {
      last = p->ch[x];
      return 0;
    }
  }
};

endsnippet

snippet setp "cout setprecision" w 
cout << fixed << setprecision(${1:10}) << ${2:ans} << endl;
endsnippet

snippet edge "read edges" w 
${3:edges}[${1:x}].push_back(${2:y});
$3[$2].push_back($1);
endsnippet

snippet fre "freopen file" w 
#ifdef HOME
freopen("${1:data}.in", "r", stdin);
freopen("$1.out", "w", stdout);
#endif
endsnippet

snippet lrflow "Dinic LR" w 

template<int N, int E, typename Type, Type INF>
class MaxFlow {
public:
  int edge, node, bridge, src, dst, source, sink;
  int level[N], current[N];
  int first[N], next[E << 1], to[E << 1];
  Type cap[E << 1], hasTo;

  int Node() { return node++; }

  void Init() {
    node = 4, edge = 1;
    hasTo = src = 0, dst = 1, source = 2, sink = 3;
    memset(first, 0, sizeof(first));
    bridge = Add(sink, source, INF);
  }

  int add(int x, int y, Type z) {
    next[++edge] = first[x]; first[x] = edge; 
    to[edge] = y; cap[edge] = z;
    return edge;
  }

  int Add(int x, int y, Type z) {
    add(y, x, 0);
    return add(x, y, z);
  }

  void LRAdd(int x, int y, Type L, Type R) {
    if (L == 0) Add(x, y, R);
    else {
      hasTo += L;
      Add(src, y, L);
      Add(x, dst, L);
      Add(x, y, R - L);
    }
  }

  Type Dinic() {
    while (Bfs(src, dst)) Dfs(src, dst, INF);
    if (hasTo != GetFlow(src)) return -1;

    while (Bfs(source, sink)) Dfs(source, sink, INF);
    return GetFlow(source);
  }

private:
  Type GetFlow(int x) {
    Type ans = 0;
    for (int go = first[x]; go; go = next[go]) if ((go ^ 1) != bridge) ans += cap[go ^ 1];
    return ans;
  }

  bool Bfs(int source, int sink) {
    queue<int> q;
    fill(level, level + node, 0);
    q.push(source), level[source] = 1;
    while(q.size()) {
      int x = q.front(); q.pop();
      for (int go = current[x] = first[x]; go; go = next[go]) if (cap[go] > 0 && !level[to[go]]) {
        int y = to[go];
        level[y] = level[x] + 1;
        q.push(y);
      }
    }
    return level[sink];
  }

  Type Dfs(int x, int sink, Type flow) {
    if (x == sink || flow == 0) return flow;
    Type ans = 0, tmp;
    for (int &go = current[x]; go; go = next[go]) if (cap[go] > 0) {
      int y = to[go];
      if (level[y] == level[x] + 1 && (tmp = Dfs(y, sink, min(flow, cap[go]))) > 0) {
        ans += tmp, flow -= tmp;
        cap[go] -= tmp, cap[go ^ 1] += tmp;
        if (flow == 0) break;
      }
    }
    return ans;
  }
};
MaxFlow<${1:N}, ${2:N}, ${3:int}, ${4:1 << 30}> net;
endsnippet
